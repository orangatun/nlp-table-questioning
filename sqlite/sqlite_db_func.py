from .sqlite_db import get_db

def user_signup(username, hashed_password):
    """Adds user details to database.
    Takes in two parameters 
    `username`: Username of the user account
    `password`: Password of the user account
    If the username is already present in the database, it returns an error.
    """
    db = get_db()
    error = None
    try:
        db.execute(
            "INSERT INTO user (username, password) VALUES (?, ?)",
            (username, hashed_password),
        )
        db.commit()
    except db.IntegrityError:
        error = f"User {username} is already registered."
    
    return error

def get_user_by_name(username):
    """Returns user details
    Takes one parameter.
    `username`: Username of the user account
    Returns a single row of user details.
    """
    db = get_db()
    user = db.execute(
        'SELECT * FROM user WHERE username = ?', (username,)
    ).fetchone()
    return user


def get_user_by_id(user_id):
    """Returns user details
    Takes one parameter.
    `user_id`: autogenerated unique key in the database for a user
    Returns a single row of user details.
    """
    db = get_db()
    user = db.execute(
        'SELECT * FROM user WHERE id = ?', (user_id,)
    ).fetchone()
    return user

def add_file(user_id, file_name, file_path):
    """Adds file details to database
    Takes three parameters
    `user_id`: The id of the user uploading the file
    `file_name`: The name of the file
    `file_path`: Path on disk where the file is saved.
    """
    db = get_db()
    error = None
    inserted_id = None
    try:
        inserted_id = db.execute(
            "INSERT INTO csv_file (user_id, file_name, file_path) VALUES (?, ?, ?) RETURNING id",
            (user_id, file_name, file_path),
        ).fetchone()['id']
        db.commit()
    except db.IntegrityError:
        error = f"File insertion failed."
    
    if inserted_id is not None and error is None:
        return (error, inserted_id)
    return (error, "-1")

def get_file_id_by_name(user_id, file_name):
    """Returns a `file_id` value
    Takes two parameters:
    `user_id`: unique id of the user who uploaded the file
    `file_name`: file name of the file uploaded
    If there are multiple uploads by the same user, with a file with the same name
    this returns the id of most recent file uploaded by a user with a file name
    """
    db = get_db()
    file_id = db.execute(
        'SELECT id FROM csv_file WHERE user_id = ? AND file_name = ? ORDERBY uploaded DESC', (user_id, file_name)
    ).fetchone()

    return file_id


def add_question(file_id, question):
    """Returns (error, question_id)
    Saves a question asked about a file, to the database.
    Takes two parameters:
    `file_id`: Unique id of the file that the question is being asked on.
    `question`: Question string that the user is asking
    Returns a tuple with:
    `error` is None if the question is inserted successfully.
    `question_id` is the autogenerated unique id of the question inserted in db.
    """
    db = get_db()
    error = None
    inserted_id = None
    try:
        inserted_id = db.execute(
            "INSERT INTO question (file_id, question) VALUES (?, ?) RETURNING id",
            (file_id, question),
        ).fetchone()['id']
        db.commit()
    except db.IntegrityError:
        error = f"Question insertion failed."
    
    if inserted_id is not None and error is None:
        return (error, inserted_id)
    return (error, "-1")

def add_response_to_question(answer, question_id):
    """Returns (error, question_id)
    Updates the question row with the AI's response to the question asked.
    Takes two parameters:
    `answer`: Unique id of the file that the question is being asked on.
    `question`: Question string that the user is asking
    Returns a tuple with:
    `error` is None if the question is inserted successfully.
    `question_id` is the autogenerated unique id of the question inserted in db.
    """
    db = get_db()
    error = None
    try:
        updated_id = db.execute(
            "UPDATE question SET response = ? WHERE id = ? RETURNING id", 
            (answer, question_id),
        ).fetchone()['id']
        db.commit()
    except db.Error:
        error = "Updating answer failed."

    if updated_id is not None and error is None:
        return (error, updated_id)
    return (error, "-1")

def get_questions_by_user_id(user_id):
    """Returns dict of files that the user uploaded, with questions and AI responses saved for a every file.
    Takes one parameter:
    `user_id`: Unique id of a user in the user table.
    Returns:
    A processed dict with the user details in the format 
    {'file_id':{ 'file_name': 'name', 'uploaded': 'upload date', 'questions:[{'question_id':'question id', 'question_time':'time asked', 'response':'AI's response'}...]}
    """
    db = get_db()
    files = db.execute(
        'SELECT f.id as file_id, f.file_name as file_name, f.uploaded as uploaded, q.id as question_id, q.req_time as question_time, q.question as question, q.response as response FROM user u JOIN csv_file f ON u.id = f.user_id LEFT JOIN question q ON f.id = q.file_id WHERE u.id = ? ORDER BY u.id, f.id, q.id', (user_id,)
    ).fetchall()
    res = {}
    for row in files:
        if row['file_id'] not in res:
            res[row['file_id']] = {}
            res[row['file_id']]['file_name'] = row['file_name']
            res[row['file_id']]['uploaded'] = row['uploaded']
            res[row['file_id']]['questions'] = []
        if(row['question']):
            q_tmp = {}
            q_tmp['question'] = row['question']
            q_tmp['question_time'] = row['question_time']
            q_tmp['response'] = row['response']
            res[row['file_id']]['questions'].append(q_tmp)
    return res
